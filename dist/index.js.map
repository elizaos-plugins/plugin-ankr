{"version":3,"sources":["../src/index.ts","../src/environment.ts","../src/actions/actionGetTokenHoldersCount.ts","../src/error/base.ts","../src/ankr/blockchains.ts","../src/ankr/handlerFactory.ts","../src/actions/actionGetTokenPrice.ts","../src/actions/actionGetTokenTransfers.ts","../src/actions/actionGetAccountBalance.ts","../src/actions/actionGetTransactionsByAddress.ts","../src/actions/actionGetTransactionsByHash.ts","../src/actions/actionGetBlockchainStats.ts","../src/actions/actionGetCurrencies.ts","../src/actions/actionGetInteractions.ts","../src/actions/actionGetNFTHolders.ts","../src/actions/actionGetNFTTransfers.ts","../src/actions/actionGetNFTMetadata.ts","../src/actions/actionGetNFTsByOwner.ts"],"sourcesContent":["import { Plugin } from \"@elizaos/core\";\nimport chalk from \"chalk\";\nimport Table from \"cli-table3\";\nimport ora from \"ora\";\nimport { getConfig } from \"./environment\";\nimport { actionGetTokenHoldersCount } from \"./actions/actionGetTokenHoldersCount\";\nimport { actionGetTokenPrice } from \"./actions/actionGetTokenPrice\";\nimport { actionGetTokenTransfers } from \"./actions/actionGetTokenTransfers\";\nimport { actionGetAccountBalance } from \"./actions/actionGetAccountBalance\";\nimport { actionGetTransactionsByAddress } from \"./actions/actionGetTransactionsByAddress\";\nimport { actionGetTransactionsByHash } from \"./actions/actionGetTransactionsByHash\";\nimport { actionGetBlockchainStats } from \"./actions/actionGetBlockchainStats\";\nimport { actionGetCurrencies } from \"./actions/actionGetCurrencies\";\nimport { actionGetInteractions } from \"./actions/actionGetInteractions\";\nimport { actionGetNFTHolders } from \"./actions/actionGetNFTHolders\";\nimport { actionGetNFTTransfers } from \"./actions/actionGetNFTTransfers\";\nimport { actionGetNFTMetadata } from \"./actions/actionGetNFTMetadata\";\nimport { actionGetNFTsByOwner } from \"./actions/actionGetNFTsByOwner\";\n\n// Start the loader\nconst spinner = ora({\n  text: chalk.cyan(\"Initializing ANKR Plugin...\"),\n  spinner: \"dots12\",\n  color: \"cyan\",\n}).start();\n\nconst actions = [\n  actionGetTokenHoldersCount,\n  actionGetTokenPrice,\n  actionGetTokenTransfers,\n  actionGetAccountBalance,\n  actionGetTransactionsByAddress,\n  actionGetTransactionsByHash,\n  actionGetBlockchainStats,\n  actionGetCurrencies,\n  actionGetInteractions,\n  actionGetNFTHolders,\n  actionGetNFTTransfers,\n  actionGetNFTMetadata,\n  actionGetNFTsByOwner,\n];\n\n// Get NVIDIA_NIM_SPASH from config\nconst ANKR_SPASH = getConfig().ANKR_API_KEY;\n\n// Initial banner\n// Only show splash screen if NVIDIA_NIM_SPASH is true\nif (ANKR_SPASH) {\n  // Initial banner with chalk styling\n  console.log(`\\n${chalk.cyan(\"┌────────────────────────────────────────┐\")}`);\n  console.log(\n    chalk.cyan(\"│\") +\n      chalk.yellow.bold(\"          ANKR PLUGIN             \") +\n      chalk.cyan(\" │\")\n  );\n  console.log(chalk.cyan(\"├────────────────────────────────────────┤\"));\n  console.log(\n    chalk.cyan(\"│\") +\n      chalk.white(\"  Initializing ANKR Services...    \") +\n      chalk.cyan(\"│\")\n  );\n  console.log(\n    chalk.cyan(\"│\") +\n      chalk.white(\"  Version: 0.2.0                        \") +\n      chalk.cyan(\"│\")\n  );\n  console.log(chalk.cyan(\"└────────────────────────────────────────┘\"));\n\n  // Stop the loader\n  spinner.succeed(chalk.green(\"ANKR Plugin initialized successfully!\"));\n\n  // Create a beautiful table for actions\n  const actionTable = new Table({\n    head: [\n      chalk.cyan(\"Action\"),\n      chalk.cyan(\"H\"),\n      chalk.cyan(\"V\"),\n      chalk.cyan(\"E\"),\n      chalk.cyan(\"Similes\"),\n    ],\n    style: {\n      head: [],\n      border: [\"cyan\"],\n    },\n  });\n\n  // Format and add action information\n  for (const action of actions) {\n    actionTable.push([\n      chalk.white(action.name),\n      typeof action.handler === \"function\" ? chalk.green(\"✓\") : chalk.red(\"✗\"),\n      typeof action.validate === \"function\" ? chalk.green(\"✓\") : chalk.red(\"✗\"),\n      action.examples?.length > 0 ? chalk.green(\"✓\") : chalk.red(\"✗\"),\n      chalk.gray(action.similes?.join(\", \") || \"none\"),\n    ]);\n  }\n\n  // Display the action table\n  console.log(`\\n${actionTable.toString()}`);\n\n  // Plugin status with a nice table\n  const statusTable = new Table({\n    style: {\n      border: [\"cyan\"],\n    },\n  });\n\n  statusTable.push(\n    [chalk.cyan(\"Plugin Status\")],\n    [chalk.white(\"Name    : \") + chalk.yellow(\"plugin-ankr\")],\n    [chalk.white(\"Actions : \") + chalk.green(actions.length.toString())],\n    [chalk.white(\"Status  : \") + chalk.green(\"Loaded & Ready\")]\n  );\n\n  console.log(`\\n${statusTable.toString()}\\n`);\n} else {\n  // Stop the loader silently if splash is disabled\n  spinner.stop();\n}\n\nconst ankrPlugin: Plugin = {\n  name: \"plugin-ankr\",\n  description: \"Ankr Plugin for web3\",\n  actions: actions,\n  evaluators: [],\n};\n\nexport { ankrPlugin };\nexport default ankrPlugin;\n","import { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\n// ANKR API Configuration\nexport const ANKR_ENDPOINT = \"https://rpc.ankr.com/multichain/\";\n\nexport const ankrEnvSchema = z.object({\n  ANKR_API_KEY: z.string().min(1, \"ANKR_API_KEY is required\"),\n});\n\nexport type ankrConfig = z.infer<typeof ankrEnvSchema>;\n\nexport function getConfig(): ankrConfig {\n  return {\n    ANKR_API_KEY: process.env.ANKR_API_KEY || \"\",\n  };\n}\n\nexport async function validateAnkrConfig(\n  runtime: IAgentRuntime\n): Promise<ankrConfig> {\n  try {\n    const envConfig = getConfig();\n\n    const config = {\n      ANKR_API_KEY:\n        process.env.ANKR_API_KEY ||\n        runtime.getSetting(\"ANKR_API_KEY\") ||\n        envConfig.ANKR_API_KEY,\n    };\n\n    return ankrEnvSchema.parse(config);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Failed to validate ANKR configuration: ${errorMessage}`);\n  }\n}\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetTokenHoldersCountReply,\n  GetTokenHoldersCountRequest as AnkrGetTokenHoldersCountRequest,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getTokenHoldersCountRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get token holders count for\"),\n  contractAddress: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The contract address of the token\"),\n});\n\ntype GetTokenHoldersCountRequest = z.infer<\n  typeof getTokenHoldersCountRequestSchema\n>;\n\n/**\n * Validates the token holders count request\n */\nconst validateGetTokenHoldersCountRequest = (\n  content: unknown\n): content is GetTokenHoldersCountRequest => {\n  const result = getTokenHoldersCountRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n/**\n * Formats the token holders count response into a human-readable string\n */\nconst formatGetTokenHoldersCountReply = (\n  request: GetTokenHoldersCountRequest,\n  response: GetTokenHoldersCountReply\n): string => {\n  // Format the response text\n  let formattedText = `Token Holders Count on ${request.blockchain.toUpperCase()}:\\n\\n`;\n  formattedText += `Current Holders: ${response.latestHoldersCount.toLocaleString()}\\n\\n`;\n  formattedText += \"Historical Data:\\n\";\n\n  response.holderCountHistory.forEach((history, index: number) => {\n    const date = new Date(history.lastUpdatedAt).toLocaleDateString();\n    formattedText += `\n${index + 1}. ${date}\n   Holders: ${history.holderCount.toLocaleString()}\n   Total Amount: ${Number(history.totalAmount).toLocaleString()}`;\n  });\n\n  if (response.syncStatus) {\n    formattedText += `\n\nSync Status: ${response.syncStatus.status} (${response.syncStatus.lag})`;\n  }\n\n  return formattedText;\n};\n\n/**\n * Handles the API call to get token holders count\n */\nconst getTokenHoldersCountHandler = (\n  provider: AnkrProvider,\n  request: GetTokenHoldersCountRequest\n): Promise<GetTokenHoldersCountReply> => {\n  return provider.getTokenHoldersCount({\n    blockchain: request.blockchain as Blockchain,\n    contractAddress: request.contractAddress,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetTokenHoldersCount: Action = {\n  name: \"GET_TOKEN_HOLDERS_COUNT_ANKR\",\n  similes: [\n    \"COUNT_HOLDERS\",\n    \"TOTAL_HOLDERS\",\n    \"HOLDERS_COUNT\",\n    \"NUMBER_OF_HOLDERS\",\n  ],\n  description:\n    \"Get the total number of holders and historical data for a specific token.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"How many holders does 0xdAC17F958D2ee523a2206206994597C13D831ec7 have on eth?\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetTokenHoldersCount\",\n    requestValidator: validateGetTokenHoldersCountRequest,\n    requestSchema: getTokenHoldersCountRequestSchema,\n    methodHandler: getTokenHoldersCountHandler,\n    responseFormatter: formatGetTokenHoldersCountReply,\n  }),\n};\n\nexport default actionGetTokenHoldersCount;\n","export class HyperbolicError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'HyperbolicError';\n    Object.setPrototypeOf(this, HyperbolicError.prototype);\n  }\n}\n\nexport class ConfigurationError extends HyperbolicError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ConfigurationError';\n    Object.setPrototypeOf(this, ConfigurationError.prototype);\n  }\n}\n\nexport class APIError extends HyperbolicError {\n  constructor(message: string, public statusCode?: number) {\n    super(message);\n    this.name = 'APIError';\n    Object.setPrototypeOf(this, APIError.prototype);\n  }\n}\n\nexport class ValidationError extends HyperbolicError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n\nexport class SSHError extends HyperbolicError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'SSHError';\n    Object.setPrototypeOf(this, SSHError.prototype);\n  }\n}\n\nexport class GPUError extends HyperbolicError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'GPUError';\n    Object.setPrototypeOf(this, GPUError.prototype);\n  }\n}\n","// Define blockchain enum first\nexport enum Blockchains {\n  // Mainnets\n  ARBITRUM = \"arbitrum\",\n  AVALANCHE = \"avalanche\",\n  BASE = \"base\",\n  BSC = \"bsc\",\n  ETH = \"eth\",\n  FANTOM = \"fantom\",\n  FLARE = \"flare\",\n  GNOSIS = \"gnosis\",\n  LINEA = \"linea\",\n  OPTIMISM = \"optimism\",\n  POLYGON = \"polygon\",\n  POLYGON_ZKEVM = \"polygon_zkevm\",\n  ROLLUX = \"rollux\",\n  SCROLL = \"scroll\",\n  SYSCOIN = \"syscoin\",\n  TELOS = \"telos\",\n  XAI = \"xai\",\n  XLAYER = \"xlayer\",\n  STORY_MAINNET = \"story_mainnet\",\n\n  // Testnets\n  AVALANCHE_FUJI = \"avalanche_fuji\",\n  BASE_SEPOLIA = \"base_sepolia\",\n  ETH_HOLESKY = \"eth_holesky\",\n  ETH_SEPOLIA = \"eth_sepolia\",\n  OPTIMISM_TESTNET = \"optimism_testnet\",\n  POLYGON_AMOY = \"polygon_amoy\",\n  STORY_TESTNET = \"story_testnet\",\n}\n\n// Export the array of blockchain values for Zod compatibility\nexport const blockchains = Object.values(Blockchains) as readonly string[];\n\n// Define the BlockchainTag type\nexport type BlockchainTag = Blockchains;\n\n// Define the blockchain info map using the enum\nexport const blockchainInfoMap: Record<\n  Blockchains,\n  { tag: Blockchains; fullName: string; isTestnet?: boolean }\n> = {\n  // Mainnets\n  [Blockchains.ARBITRUM]: { tag: Blockchains.ARBITRUM, fullName: \"Arbitrum\" },\n  [Blockchains.AVALANCHE]: {\n    tag: Blockchains.AVALANCHE,\n    fullName: \"Avalanche\",\n  },\n  [Blockchains.BASE]: { tag: Blockchains.BASE, fullName: \"Base\" },\n  [Blockchains.BSC]: { tag: Blockchains.BSC, fullName: \"Binance Smart Chain\" },\n  [Blockchains.ETH]: { tag: Blockchains.ETH, fullName: \"Ethereum\" },\n  [Blockchains.FANTOM]: { tag: Blockchains.FANTOM, fullName: \"Fantom\" },\n  [Blockchains.FLARE]: { tag: Blockchains.FLARE, fullName: \"Flare\" },\n  [Blockchains.GNOSIS]: { tag: Blockchains.GNOSIS, fullName: \"Gnosis\" },\n  [Blockchains.LINEA]: { tag: Blockchains.LINEA, fullName: \"Linea\" },\n  [Blockchains.OPTIMISM]: { tag: Blockchains.OPTIMISM, fullName: \"Optimism\" },\n  [Blockchains.POLYGON]: { tag: Blockchains.POLYGON, fullName: \"Polygon\" },\n  [Blockchains.POLYGON_ZKEVM]: {\n    tag: Blockchains.POLYGON_ZKEVM,\n    fullName: \"Polygon zkEVM\",\n  },\n  [Blockchains.ROLLUX]: { tag: Blockchains.ROLLUX, fullName: \"Rollux\" },\n  [Blockchains.SCROLL]: { tag: Blockchains.SCROLL, fullName: \"Scroll\" },\n  [Blockchains.SYSCOIN]: { tag: Blockchains.SYSCOIN, fullName: \"Syscoin\" },\n  [Blockchains.TELOS]: { tag: Blockchains.TELOS, fullName: \"Telos\" },\n  [Blockchains.XAI]: { tag: Blockchains.XAI, fullName: \"Xai\" },\n  [Blockchains.XLAYER]: { tag: Blockchains.XLAYER, fullName: \"XLayer\" },\n  [Blockchains.STORY_MAINNET]: {\n    tag: Blockchains.STORY_MAINNET,\n    fullName: \"Story\",\n  },\n\n  // Testnets\n  [Blockchains.AVALANCHE_FUJI]: {\n    tag: Blockchains.AVALANCHE_FUJI,\n    fullName: \"Avalanche Fuji\",\n    isTestnet: true,\n  },\n  [Blockchains.BASE_SEPOLIA]: {\n    tag: Blockchains.BASE_SEPOLIA,\n    fullName: \"Base Sepolia\",\n    isTestnet: true,\n  },\n  [Blockchains.ETH_HOLESKY]: {\n    tag: Blockchains.ETH_HOLESKY,\n    fullName: \"Ethereum Holesky\",\n    isTestnet: true,\n  },\n  [Blockchains.ETH_SEPOLIA]: {\n    tag: Blockchains.ETH_SEPOLIA,\n    fullName: \"Ethereum Sepolia\",\n    isTestnet: true,\n  },\n  [Blockchains.OPTIMISM_TESTNET]: {\n    tag: Blockchains.OPTIMISM_TESTNET,\n    fullName: \"Optimism Testnet\",\n    isTestnet: true,\n  },\n  [Blockchains.POLYGON_AMOY]: {\n    tag: Blockchains.POLYGON_AMOY,\n    fullName: \"Polygon Amoy\",\n    isTestnet: true,\n  },\n  [Blockchains.STORY_TESTNET]: {\n    tag: Blockchains.STORY_TESTNET,\n    fullName: \"Story Testnet\",\n    isTestnet: true,\n  },\n};\n\n// Helper function to get blockchain tag from full name (case insensitive)\nexport function getBlockchainTagFromName(\n  name: string\n): BlockchainTag | undefined {\n  const normalizedName = name.toLowerCase().trim();\n\n  // Direct match with tag\n  const directMatch = Object.values(Blockchains).find(\n    (value) => value.toLowerCase() === normalizedName\n  );\n  if (directMatch) {\n    return directMatch as BlockchainTag;\n  }\n\n  // Match with full name\n  const entry = Object.entries(blockchainInfoMap).find(\n    ([_, info]) => info.fullName.toLowerCase() === normalizedName\n  );\n\n  return entry?.[0] as BlockchainTag | undefined;\n}\n\n// Helper function to check if a blockchain is a testnet\nexport function isTestnet(blockchain: BlockchainTag): boolean {\n  return !!blockchainInfoMap[blockchain]?.isTestnet;\n}\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport {\n  composeContext,\n  elizaLogger,\n  generateObject,\n  HandlerCallback,\n  IAgentRuntime,\n  Memory,\n  ModelClass,\n  State,\n} from \"@elizaos/core\";\nimport { AnkrProvider } from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { validateAnkrConfig } from \"../environment\";\nimport { APIError, ConfigurationError, ValidationError } from \"../error/base\";\nimport { blockchains, blockchainInfoMap } from \"./blockchains\";\n\n// ------------------------------------------------------------------------------------------------\n// Generic Handler Factory\n// ------------------------------------------------------------------------------------------------\nexport type AnkrHandlerOptions<TRequest, TResponse> = {\n  methodName: string;\n  methodHandler: (\n    provider: AnkrProvider,\n    params: TRequest\n  ) => Promise<TResponse>;\n  requestSchema: z.ZodType<TRequest>;\n  requestValidator: (content: unknown) => content is TRequest;\n  responseFormatter: (request: TRequest, response: TResponse) => string;\n};\n\n// Create a standardized template generator function\nconst createStandardTemplate = (schema: z.ZodType<any>): string => {\n  // Extract descriptions from schema to provide better guidance\n  const schemaDescription = schema.description || \"\";\n\n  // Get the shape of the schema to understand its properties\n  const shape = (schema as any)._def?.shape || {};\n\n  // Build property descriptions\n  const propertyDescriptions = Object.entries(shape || {})\n    .map(([key, value]: [string, any]) => {\n      const desc = value?.description || \"\";\n      return `- ${key}: ${desc}`;\n    })\n    .join(\"\\n\");\n\n  // Get supported blockchains if the schema has a blockchain property\n  const hasBlockchains = shape?.blockchain !== undefined;\n\n  // Create a more informative blockchain section with both tags and full names\n  const blockchainsSection = hasBlockchains\n    ? `\\n## Supported Blockchains\\n\\n### Mainnets\\n${Object.values(\n        blockchainInfoMap\n      )\n        .filter((info) => !info.isTestnet)\n        .map((info) => `- ${info.fullName} (${info.tag})`)\n        .join(\"\\n\")}\\n\\n### Testnets\\n${Object.values(blockchainInfoMap)\n        .filter((info) => info.isTestnet)\n        .map((info) => `- ${info.fullName} (${info.tag})`)\n        .join(\"\\n\")}`\n    : \"\";\n\n  return `Respond with a JSON markdown block containing only the extracted values\n- Skip any values that cannot be determined.\n- If no specific blockchain is mentioned, assume the user wants to check all supported blockchains.\n- When a blockchain is mentioned by its full name (e.g., \"Ethereum\"), use the corresponding tag (e.g., \"eth\").\n\n${schemaDescription ? `## Schema Description\\n\\n${schemaDescription}\\n` : \"\"}\n${propertyDescriptions ? `## Properties\\n\\n${propertyDescriptions}\\n` : \"\"}\n${blockchainsSection}\n\n## Recent Messages\n\n<recentMessages>\n{{recentMessages}}\n</recentMessages>\n\nGiven the recent messages, extract the following information according to the schema.\n\nRespond with a JSON markdown block containing only the extracted values.`;\n};\n\nexport function createAnkrHandler<TRequest, TResponse>({\n  methodName,\n  requestValidator: validator,\n  methodHandler: apiMethod,\n  responseFormatter: formatter,\n  requestSchema: schema,\n}: AnkrHandlerOptions<TRequest, TResponse>) {\n  return async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options: { [key: string]: unknown } = {},\n    callback?: HandlerCallback\n  ): Promise<boolean> => {\n    elizaLogger.info(`[${methodName}] executing`);\n    try {\n      elizaLogger.debug(\n        { content: message.content },\n        `[${methodName}] message content`\n      );\n\n      const config = await validateAnkrConfig(runtime);\n      const apikey = config.ANKR_API_KEY;\n      if (!apikey) {\n        throw new ConfigurationError(\n          \"ANKR_API_KEY not found in environment variables\"\n        );\n      }\n      const provider = new AnkrProvider(\n        `https://rpc.ankr.com/multichain/${apikey}`\n      );\n\n      if (!state) {\n        state = (await runtime.composeState(message)) as State;\n      } else {\n        state = await runtime.updateRecentMessageState(state);\n      }\n\n      // Generate the template based on the schema\n      const template = createStandardTemplate(schema);\n\n      const context = composeContext({\n        state,\n        template,\n      });\n\n      elizaLogger.debug(`[${methodName}] composed context`, {\n        context,\n      });\n\n      const content = await generateObject({\n        schema,\n        context,\n        modelClass: ModelClass.SMALL,\n        runtime,\n      });\n\n      const request = content.object;\n      elizaLogger.info(`[${methodName}] extracted request parameters`, {\n        request,\n      });\n\n      if (!validator(request)) {\n        throw new ValidationError(\"Invalid request\");\n      }\n\n      elizaLogger.debug(`[${methodName}] API request parameters`, {\n        params: request,\n      });\n\n      try {\n        const response = await apiMethod(provider, request);\n\n        elizaLogger.debug(`[${methodName}] received response from Ankr API`, {\n          data: response,\n        });\n\n        const formattedResponse = formatter(request, response);\n        callback?.({\n          text: formattedResponse,\n          content: {\n            success: true,\n            request,\n            response,\n          },\n        });\n\n        return true;\n      } catch (error) {\n        elizaLogger.error(\"API request failed\", { error });\n        throw new APIError(`Failed to fetch ${methodName} data`);\n      }\n    } catch (error) {\n      elizaLogger.error(\"Handler execution failed\", {\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n      callback?.({\n        text: `Error in ${methodName}: ${errorMessage}`,\n        content: {\n          error,\n        },\n      });\n\n      if (\n        error instanceof ConfigurationError ||\n        error instanceof ValidationError ||\n        error instanceof APIError\n      ) {\n        throw error;\n      }\n\n      throw new APIError(\n        `Failed to execute ${methodName} action: ${error}`,\n        error\n      );\n    }\n  };\n}\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  GetTokenPriceReply,\n  Blockchain,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n/**\n * Schema for token price requests\n */\nexport const getTokenPriceRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to check the token price on\"),\n  contractAddress: z\n    .string()\n    .refine((val) => !val || val.startsWith(\"0x\"), {\n      message: \"Contract address must either be empty or start with '0x'\",\n    })\n    .optional()\n    .describe(\n      \"The contract address of the token to check the price of. Leave empty for native token.\"\n    ),\n});\n\ntype GetTokenPriceRequest = z.infer<typeof getTokenPriceRequestSchema>;\n\n/**\n * Validates the token price request\n */\nconst validateGetTokenPriceRequest = (\n  content: unknown\n): content is GetTokenPriceRequest => {\n  const result = getTokenPriceRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n/**\n * Formats the token price response into a human-readable string\n */\nconst formatGetTokenPriceReply = (\n  request: GetTokenPriceRequest,\n  response: GetTokenPriceReply\n): string => {\n  const price = Number(response.usdPrice).toFixed(5);\n  const contractDisplay = response.contractAddress\n    ? `${response.contractAddress.slice(\n        0,\n        6\n      )}...${response.contractAddress.slice(-4)}`\n    : \"Native Token\";\n\n  return (\n    `Current token price on ${request.blockchain}:\\n\\n` +\n    `Price: $${price} USD\\n` +\n    `Contract: ${contractDisplay}\\n` +\n    `Sync Status: ${response.syncStatus.status} (lag: ${response.syncStatus.lag})`\n  );\n};\n\n/**\n * Handles the API call to get token price\n */\nconst getTokenPriceHandler = async (\n  provider: AnkrProvider,\n  request: GetTokenPriceRequest\n): Promise<GetTokenPriceReply> => {\n  return provider.getTokenPrice({\n    blockchain: request.blockchain as Blockchain,\n    contractAddress: request.contractAddress,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetTokenPrice: Action = {\n  name: \"GET_TOKEN_PRICE_ANKR\",\n  similes: [\"CHECK_PRICE\", \"TOKEN_PRICE\", \"CRYPTO_PRICE\", \"PRICE_CHECK\"],\n  description:\n    \"Get the current USD price for any token on supported blockchains.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"What's the current price of ETH?\",\n        },\n      },\n    ],\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"What's the current price of 0x8290333cef9e6d528dd5618fb97a76f268f3edd4 token on eth?\",\n        },\n      },\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetTokenPrice\",\n    requestValidator: validateGetTokenPriceRequest,\n    requestSchema: getTokenPriceRequestSchema,\n    methodHandler: getTokenPriceHandler,\n    responseFormatter: formatGetTokenPriceReply,\n  }),\n};\n\nexport default actionGetTokenPrice;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetTokenTransfersReply,\n  GetTransfersRequest,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getTokenTransfersRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get token transfers from\"),\n  address: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The wallet address to get token transfers for\"),\n  contractAddress: z\n    .string()\n    .refine((val) => !val || val.startsWith(\"0x\"), {\n      message: \"Contract address must be empty or start with 0x\",\n    })\n    .optional()\n    .describe(\"The token contract address (optional)\"),\n  fromTimestamp: z\n    .number()\n    .optional()\n    .describe(\"Start timestamp for the transfers (optional)\"),\n  toTimestamp: z\n    .number()\n    .optional()\n    .describe(\"End timestamp for the transfers (optional)\"),\n  descOrder: z\n    .boolean()\n    .default(true)\n    .describe(\"Whether to sort transfers in descending order\"),\n});\n\ntype GetTokenTransfersRequestType = z.infer<\n  typeof getTokenTransfersRequestSchema\n>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetTokenTransfersRequest = (\n  content: unknown\n): content is GetTokenTransfersRequestType => {\n  const result = getTokenTransfersRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetTokenTransfersReply = (\n  request: GetTokenTransfersRequestType,\n  response: GetTokenTransfersReply\n): string => {\n  const { transfers, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `Token transfers for ${request.address} on ${request.blockchain}:\\n\\n`;\n\n  if (transfers.length === 0) {\n    formattedText += \"No token transfers found\";\n    return formattedText;\n  }\n\n  transfers.forEach((transfer, index) => {\n    const date = new Date(transfer.timestamp * 1000).toLocaleString();\n    const value = Number(transfer.value);\n\n    formattedText += `${index + 1}. ${transfer.tokenName} (${\n      transfer.tokenSymbol\n    })\\n`;\n\n    if (transfer.fromAddress === request.address) {\n      formattedText += `   Sent: ${value} ${transfer.tokenSymbol}\\n`;\n      formattedText += `   To: ${transfer.toAddress.slice(\n        0,\n        6\n      )}...${transfer.toAddress.slice(-4)}\\n`;\n    } else {\n      formattedText += `   Received: ${value} ${transfer.tokenSymbol}\\n`;\n      formattedText += `   From: ${transfer.fromAddress.slice(\n        0,\n        6\n      )}...${transfer.fromAddress.slice(-4)}\\n`;\n    }\n\n    formattedText += `   Contract: ${transfer.contractAddress.slice(\n      0,\n      6\n    )}...${transfer.contractAddress.slice(-4)}\\n`;\n    formattedText += `   Tx Hash: ${transfer.transactionHash.slice(\n      0,\n      6\n    )}...${transfer.transactionHash.slice(-4)}\\n`;\n    formattedText += `   Time: ${date}\\n\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `Sync Status: ${syncStatus.status} (lag: ${syncStatus.lag})`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getTokenTransfersHandler = async (\n  provider: AnkrProvider,\n  request: GetTokenTransfersRequestType\n): Promise<GetTokenTransfersReply> => {\n  const params: GetTransfersRequest = {\n    blockchain: request.blockchain as Blockchain,\n    address: [request.address],\n    descOrder: request.descOrder,\n    pageSize: 10,\n  };\n\n  if (request.fromTimestamp) {\n    params.fromTimestamp = request.fromTimestamp;\n  }\n\n  if (request.toTimestamp) {\n    params.toTimestamp = request.toTimestamp;\n  }\n\n  return provider.getTokenTransfers(params);\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetTokenTransfers: Action = {\n  name: \"GET_TOKEN_TRANSFERS_ANKR\",\n  similes: [\n    \"FETCH_TOKEN_TRANSFERS\",\n    \"SHOW_TOKEN_TRANSFERS\",\n    \"VIEW_TOKEN_TRANSFERS\",\n    \"LIST_TOKEN_TRANSFERS\",\n  ],\n  description:\n    \"Retrieve token transfer history for a specific address on the blockchain\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me token transfers for address 0xd8da6bf26964af9d7eed9e03e53415d37aa96045 on eth\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetTokenTransfers\",\n    requestValidator: validateGetTokenTransfersRequest,\n    requestSchema: getTokenTransfersRequestSchema,\n    methodHandler: getTokenTransfersHandler,\n    responseFormatter: formatGetTokenTransfersReply,\n  }),\n};\n\nexport default actionGetTokenTransfers;\n","import {\n  AnkrProvider,\n  Blockchain,\n  GetAccountBalanceReply,\n} from \"@ankr.com/ankr.js\";\nimport { Action, IAgentRuntime, Memory } from \"@elizaos/core\";\nimport { z } from \"zod\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\nimport { ValidationError } from \"../error/base\";\n\n/**\n * Schema for account balance requests\n */\nexport const getAccountBalanceRequestSchema = z.object({\n  blockchain: z\n    .union([z.nativeEnum(Blockchains), z.array(z.nativeEnum(Blockchains))])\n    .optional()\n    .describe(\"The blockchain(s) to check the balance on\"),\n  walletAddress: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\n      \"The EVM-like wallet address to check the balance of, e.g. 0x1234567890123456789012345678901234567890\"\n    ),\n});\n\ntype GetAccountBalanceRequest = z.infer<typeof getAccountBalanceRequestSchema>;\n\n/**\n * Validates the account balance request\n */\nconst validateGetAccountBalanceRequest = (\n  content: unknown\n): content is GetAccountBalanceRequest => {\n  const result = getAccountBalanceRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n/**\n * Formats the account balance response into a human-readable string\n */\nconst formatGetAccountBalanceReply = (\n  request: GetAccountBalanceRequest,\n  response: GetAccountBalanceReply\n): string => {\n  // Format the response text\n  let formattedText = `Here are the balances for wallet ${request.walletAddress}:\\n\\n`;\n  if (response.assets.length === 0) {\n    formattedText += \"No balances found\";\n    return formattedText;\n  }\n\n  response.assets.forEach((balance, index: number) => {\n    formattedText += `${index + 1}. ${balance.tokenName} (${\n      balance.tokenType\n    })\\n`;\n    formattedText += `   Balance: ${balance.balance} ${balance.tokenSymbol}\\n`;\n    if (balance.contractAddress) {\n      formattedText += `   Contract: ${balance.contractAddress}\\n`;\n    }\n    formattedText += `   USD Value: $${Number.parseFloat(\n      balance.balanceUsd\n    ).toFixed(2)}\\n\\n`;\n  });\n\n  return formattedText;\n};\n\n/**\n * Handles the API call to get account balance\n */\nconst getAccountBalanceHandler = (\n  provider: AnkrProvider,\n  request: GetAccountBalanceRequest\n): Promise<GetAccountBalanceReply> => {\n  return provider.getAccountBalance({\n    blockchain: request.blockchain as Blockchain | Blockchain[],\n    walletAddress: request.walletAddress,\n    onlyWhitelisted: true,\n    pageSize: 50,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetAccountBalance: Action = {\n  name: \"GET_ACCOUNT_BALANCE_ANKR\",\n  similes: [\n    \"CHECK_BALANCE\",\n    \"SHOW_BALANCE\",\n    \"VIEW_BALANCE\",\n    \"GET_WALLET_BALANCE\",\n  ],\n  description:\n    \"Retrieve account balance information across multiple blockchains.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me the balance for wallet 0x1234567890123456789012345678901234567890 on eth\",\n        },\n      },\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetAccountBalance\",\n    requestValidator: validateGetAccountBalanceRequest,\n    requestSchema: getAccountBalanceRequestSchema,\n    methodHandler: getAccountBalanceHandler,\n    responseFormatter: formatGetAccountBalanceReply,\n  }),\n};\n\nexport default actionGetAccountBalance;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetTransactionsByAddressReply,\n  GetTransactionsByAddressRequest,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getTransactionsByAddressRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get transactions from\"),\n  address: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The wallet address to get transactions for\"),\n  includeLogs: z\n    .boolean()\n    .default(true)\n    .describe(\"Whether to include transaction logs\"),\n  descOrder: z\n    .boolean()\n    .default(true)\n    .describe(\"Whether to sort transactions in descending order\"),\n});\n\ntype GetTransactionsByAddressRequestType = z.infer<\n  typeof getTransactionsByAddressRequestSchema\n>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetTransactionsByAddressRequest = (\n  content: unknown\n): content is GetTransactionsByAddressRequestType => {\n  const result = getTransactionsByAddressRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetTransactionsByAddressReply = (\n  request: GetTransactionsByAddressRequestType,\n  response: GetTransactionsByAddressReply\n): string => {\n  const { transactions, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `Transactions for ${request.address} on ${request.blockchain}:\\n\\n`;\n\n  if (transactions.length === 0) {\n    formattedText += \"No transactions found\";\n    return formattedText;\n  }\n\n  transactions.forEach((tx, index) => {\n    const date = new Date(Number(tx.timestamp) * 1000).toLocaleString();\n    const value = Number(tx.value) / 1e18;\n    const status = tx.status === \"0x1\" ? \"Success\" : \"Failed\";\n\n    formattedText += `${index + 1}. Transaction\\n`;\n    formattedText += `   Hash: ${tx.hash.slice(0, 6)}...${tx.hash.slice(-4)}\\n`;\n    formattedText += `   From: ${tx.from.slice(0, 6)}...${tx.from.slice(-4)}\\n`;\n\n    if (tx.to) {\n      formattedText += `   To: ${tx.to.slice(0, 6)}...${tx.to.slice(-4)}\\n`;\n    } else if (tx.contractAddress) {\n      formattedText += `   Contract Created: ${tx.contractAddress.slice(\n        0,\n        6\n      )}...${tx.contractAddress.slice(-4)}\\n`;\n    }\n\n    formattedText += `   Value: ${value.toFixed(4)} ${\n      request.blockchain === \"eth\" ? \"ETH\" : \"native tokens\"\n    }\\n`;\n    formattedText += `   Status: ${status}\\n`;\n    formattedText += `   Time: ${date}\\n\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `Sync Status: ${syncStatus.status} (lag: ${syncStatus.lag})`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getTransactionsByAddressHandler = async (\n  provider: AnkrProvider,\n  request: GetTransactionsByAddressRequestType\n): Promise<GetTransactionsByAddressReply> => {\n  return provider.getTransactionsByAddress({\n    blockchain: request.blockchain as Blockchain,\n    address: [request.address],\n    includeLogs: request.includeLogs,\n    descOrder: request.descOrder,\n    pageSize: 10,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetTransactionsByAddress: Action = {\n  name: \"GET_TRANSACTIONS_BY_ADDRESS_ANKR\",\n  similes: [\"LIST_TXS\", \"SHOW_TXS\", \"VIEW_TRANSACTIONS\", \"GET_ADDRESS_TXS\"],\n  description: \"Get transactions for a specific address on the blockchain\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me the latest transactions for address 0xd8da6bf26964af9d7eed9e03e53415d37aa96045 on eth\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetTransactionsByAddress\",\n    requestValidator: validateGetTransactionsByAddressRequest,\n    requestSchema: getTransactionsByAddressRequestSchema,\n    methodHandler: getTransactionsByAddressHandler,\n    responseFormatter: formatGetTransactionsByAddressReply,\n  }),\n};\n\nexport default actionGetTransactionsByAddress;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetTransactionsByHashReply,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getTransactionsByHashRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .optional()\n    .describe(\"The blockchain to get transaction from (optional)\"),\n  transactionHash: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The transaction hash to look up\"),\n  includeLogs: z\n    .boolean()\n    .optional()\n    .default(false)\n    .describe(\"Whether to include transaction logs\"),\n});\n\ntype GetTransactionsByHashRequest = z.infer<\n  typeof getTransactionsByHashRequestSchema\n>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetTransactionsByHashRequest = (\n  content: unknown\n): content is GetTransactionsByHashRequest => {\n  const result = getTransactionsByHashRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetTransactionsByHashReply = (\n  request: GetTransactionsByHashRequest,\n  response: GetTransactionsByHashReply\n): string => {\n  const { transactions, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `Transaction details for hash ${request.transactionHash}:\\n\\n`;\n\n  if (transactions.length === 0) {\n    formattedText += \"No transaction found with this hash\";\n    return formattedText;\n  }\n\n  transactions.forEach((tx, index) => {\n    formattedText += `Transaction #${index + 1}:\\n`;\n    formattedText += `Blockchain: ${tx.blockchain || \"Unknown\"}\\n`;\n    formattedText += `Hash: ${tx.hash || request.transactionHash}\\n`;\n    formattedText += `Block: ${tx.blockNumber}\\n`;\n    formattedText += `From: ${tx.from}\\n`;\n\n    if (tx.to) {\n      formattedText += `To: ${tx.to}\\n`;\n    } else if (tx.contractAddress) {\n      formattedText += `Contract Created: ${tx.contractAddress}\\n`;\n    }\n\n    formattedText += `Value: ${tx.value}\\n`;\n\n    if (tx.gas) {\n      formattedText += `Gas Limit: ${tx.gas}\\n`;\n    }\n\n    if (tx.gasUsed) {\n      formattedText += `Gas Used: ${tx.gasUsed}\\n`;\n    }\n\n    if (tx.gasPrice) {\n      formattedText += `Gas Price: ${tx.gasPrice}\\n`;\n    }\n\n    if (tx.status) {\n      formattedText += `Status: ${tx.status === \"1\" ? \"Success\" : \"Failed\"}\\n`;\n    }\n\n    if (tx.timestamp) {\n      const date = new Date(Number(tx.timestamp) * 1000).toLocaleString();\n      formattedText += `Time: ${date}\\n`;\n    }\n\n    if (request.includeLogs && tx.logs && tx.logs.length > 0) {\n      formattedText += `\\nLogs (${tx.logs.length}):\\n`;\n      tx.logs.forEach((log, logIndex) => {\n        formattedText += `  Log #${logIndex + 1}:\\n`;\n        formattedText += `    Address: ${log.address}\\n`;\n        formattedText += `    Topics: ${log.topics.join(\", \")}\\n`;\n\n        if (log.event) {\n          formattedText += `    Event: ${log.event.name}\\n`;\n          if (log.event.inputs && log.event.inputs.length > 0) {\n            formattedText += `    Inputs:\\n`;\n            log.event.inputs.forEach((input) => {\n              formattedText += `      ${input.name} (${input.type}): ${input.valueDecoded}\\n`;\n            });\n          }\n        }\n      });\n    }\n\n    formattedText += \"\\n\";\n  });\n\n  if (syncStatus) {\n    formattedText += `Sync Status: ${syncStatus.status} (lag: ${syncStatus.lag})\\n`;\n    formattedText += `Last Update: ${new Date(\n      syncStatus.timestamp * 1000\n    ).toLocaleString()}`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getTransactionsByHashHandler = async (\n  provider: AnkrProvider,\n  request: GetTransactionsByHashRequest\n): Promise<GetTransactionsByHashReply> => {\n  return provider.getTransactionsByHash({\n    transactionHash: request.transactionHash,\n    ...(request.blockchain && { blockchain: request.blockchain as Blockchain }),\n    includeLogs: request.includeLogs,\n    decodeLogs: request.includeLogs,\n    decodeTxData: true,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetTransactionsByHash: Action = {\n  name: \"GET_TRANSACTIONS_BY_HASH_ANKR\",\n  similes: [\n    \"FETCH_TRANSACTION_BY_HASH\",\n    \"SHOW_TRANSACTION_BY_HASH\",\n    \"VIEW_TRANSACTION_BY_HASH\",\n    \"GET_TX_BY_HASH\",\n  ],\n  description:\n    \"Retrieve transaction details by transaction hash on specified blockchain networks.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me transaction 0x5a4bf6970980a9381e6d6c78d96ab278035bbff58c383ffe96a0a2bbc7c02a4c on eth\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetTransactionsByHash\",\n    requestValidator: validateGetTransactionsByHashRequest,\n    requestSchema: getTransactionsByHashRequestSchema,\n    methodHandler: getTransactionsByHashHandler,\n    responseFormatter: formatGetTransactionsByHashReply,\n  }),\n};\n\nexport default actionGetTransactionsByHash;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory } from \"@elizaos/core\";\n// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetBlockchainStatsReply,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport {\n  blockchains,\n  blockchainInfoMap,\n  Blockchains,\n} from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getBlockchainStatsRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get statistics for\"),\n});\n\ntype GetBlockchainStatsRequest = z.infer<\n  typeof getBlockchainStatsRequestSchema\n>;\n\n/**\n * Validates the blockchain stats request\n */\nconst validateGetBlockchainStatsRequest = (\n  content: unknown\n): content is GetBlockchainStatsRequest => {\n  const result = getBlockchainStatsRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n/**\n * Formats the blockchain stats response into a human-readable string\n */\nconst formatGetBlockchainStatsReply = (\n  request: GetBlockchainStatsRequest,\n  response: GetBlockchainStatsReply\n): string => {\n  // The response contains an array of stats, but we only requested one blockchain\n  const stats = response.stats[0];\n\n  // Get the full blockchain name from the mapping\n  const blockchainInfo = blockchainInfoMap[request.blockchain];\n  const blockchainName = blockchainInfo\n    ? blockchainInfo.fullName\n    : request.blockchain;\n\n  const formattedText =\n    `Blockchain Statistics for ${blockchainName} (${request.blockchain}):\\n\\n` +\n    `Latest Block: ${stats.latestBlockNumber.toLocaleString()}\\n` +\n    `Total Transactions: ${stats.totalTransactionsCount.toLocaleString()}\\n` +\n    `Total Events: ${stats.totalEventsCount.toLocaleString()}\\n` +\n    `Block Time: ${(stats.blockTimeMs / 1000).toFixed(2)} seconds\\n` +\n    `Native Coin Price: $${Number.parseFloat(stats.nativeCoinUsdPrice).toFixed(\n      2\n    )} USD`;\n\n  return formattedText;\n};\n\n/**\n * Handles the API call to get blockchain stats\n */\nconst getBlockchainStatsHandler = async (\n  provider: AnkrProvider,\n  request: GetBlockchainStatsRequest\n): Promise<GetBlockchainStatsReply> => {\n  return provider.getBlockchainStats({\n    blockchain: request.blockchain as Blockchain,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetBlockchainStats: Action = {\n  name: \"GET_BLOCKCHAIN_STATS_ANKR\",\n  similes: [\n    \"BLOCKCHAIN_STATS\",\n    \"CHAIN_STATS\",\n    \"NETWORK_STATS\",\n    \"BLOCKCHAIN_METRICS\",\n  ],\n  description:\n    \"Retrieve statistics about a blockchain such as latest block, transaction count, and more.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me the stats for the Ethereum blockchain\",\n        },\n      },\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetBlockchainStats\",\n    requestValidator: validateGetBlockchainStatsRequest,\n    requestSchema: getBlockchainStatsRequestSchema,\n    methodHandler: getBlockchainStatsHandler,\n    responseFormatter: formatGetBlockchainStatsReply,\n  }),\n};\n\nexport default actionGetBlockchainStats;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetCurrenciesReply,\n} from \"@ankr.com/ankr.js\";\nimport { Action, ActionExample, IAgentRuntime, Memory } from \"@elizaos/core\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getCurrenciesRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get currencies for\"),\n});\n\ntype GetCurrenciesRequestType = z.infer<typeof getCurrenciesRequestSchema>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetCurrenciesRequest = (\n  content: unknown\n): content is GetCurrenciesRequestType => {\n  const result = getCurrenciesRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetCurrenciesReply = (\n  request: GetCurrenciesRequestType,\n  response: GetCurrenciesReply\n): string => {\n  const { currencies, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `Here are the top currencies on ${request.blockchain}:\\n\\n`;\n\n  if (currencies.length === 0) {\n    formattedText += \"No currencies found\";\n    return formattedText;\n  }\n\n  currencies.forEach((currency, index) => {\n    formattedText += `${index + 1}. ${currency.name} (${currency.symbol})\\n`;\n\n    if (\n      currency.address &&\n      currency.address !== \"0x0000000000000000000000000000000000000000\"\n    ) {\n      formattedText += `   Contract: ${currency.address.slice(\n        0,\n        6\n      )}...${currency.address.slice(-4)}\\n`;\n    } else {\n      formattedText += `   Native Token\\n`;\n    }\n\n    formattedText += `   Decimals: ${currency.decimals}\\n\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `Sync Status: ${syncStatus.status} (lag: ${syncStatus.lag})`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getCurrenciesHandler = async (\n  provider: AnkrProvider,\n  request: GetCurrenciesRequestType\n): Promise<GetCurrenciesReply> => {\n  return provider.getCurrencies({\n    blockchain: request.blockchain as Blockchain,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetCurrencies: Action = {\n  name: \"GET_CURRENCIES_ANKR\",\n  similes: [\n    \"LIST_CURRENCIES\",\n    \"SHOW_CURRENCIES\",\n    \"VIEW_CURRENCIES\",\n    \"FETCH_CURRENCIES\",\n  ],\n  description:\n    \"Retrieve information about currencies on specified blockchain networks.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me the top currencies on Ethereum\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetCurrencies\",\n    requestValidator: validateGetCurrenciesRequest,\n    requestSchema: getCurrenciesRequestSchema,\n    methodHandler: getCurrenciesHandler,\n    responseFormatter: formatGetCurrenciesReply,\n  }),\n};\n\nexport default actionGetCurrencies;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetInteractionsReply,\n  GetInteractionsRequest,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getInteractionsRequestSchema = z.object({\n  address: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The wallet address to get interactions for\"),\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .optional()\n    .describe(\"The blockchain to check interactions on (optional)\"),\n});\n\ntype GetInteractionsRequestType = z.infer<typeof getInteractionsRequestSchema>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetInteractionsRequest = (\n  content: unknown\n): content is GetInteractionsRequestType => {\n  const result = getInteractionsRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetInteractionsReply = (\n  request: GetInteractionsRequestType,\n  response: GetInteractionsReply\n): string => {\n  const { blockchains, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `Blockchain interactions for address ${request.address}:\\n\\n`;\n\n  if (blockchains.length === 0) {\n    formattedText += \"No interactions found on any blockchain\";\n    return formattedText;\n  }\n\n  formattedText += `This address has interacted with the following blockchains:\\n`;\n  blockchains.forEach((chain, index) => {\n    formattedText += `${index + 1}. ${chain}\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `\\nSync Status: ${syncStatus.status} (lag: ${syncStatus.lag})`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getInteractionsHandler = async (\n  provider: AnkrProvider,\n  request: GetInteractionsRequestType\n): Promise<GetInteractionsReply> => {\n  return provider.getInteractions({\n    address: request.address,\n    // Only include blockchain if it's provided\n    ...(request.blockchain && { blockchain: request.blockchain as Blockchain }),\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetInteractions: Action = {\n  name: \"GET_INTERACTIONS_ANKR\",\n  similes: [\n    \"FETCH_INTERACTIONS\",\n    \"SHOW_INTERACTIONS\",\n    \"VIEW_INTERACTIONS\",\n    \"LIST_INTERACTIONS\",\n  ],\n  description:\n    \"Retrieve interactions between wallets and smart contracts on specified blockchain networks.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me interactions for the wallet 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetInteractions\",\n    requestValidator: validateGetInteractionsRequest,\n    requestSchema: getInteractionsRequestSchema,\n    methodHandler: getInteractionsHandler,\n    responseFormatter: formatGetInteractionsReply,\n  }),\n};\n\nexport default actionGetInteractions;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetNFTHoldersReply,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getNFTHoldersRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .default(Blockchains.ETH)\n    .describe(\"The blockchain to get NFT holders from\"),\n  contractAddress: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The NFT contract address to get holders for\"),\n});\n\ntype GetNFTHoldersRequest = z.infer<typeof getNFTHoldersRequestSchema>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetNFTHoldersRequest = (\n  content: unknown\n): content is GetNFTHoldersRequest => {\n  const result = getNFTHoldersRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetNFTHoldersReply = (\n  request: GetNFTHoldersRequest,\n  response: GetNFTHoldersReply\n): string => {\n  const { holders, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `NFT Holders for contract ${request.contractAddress} on ${request.blockchain}:\\n\\n`;\n\n  if (holders.length === 0) {\n    formattedText += \"No holders found for this NFT contract\";\n    return formattedText;\n  }\n\n  formattedText += `Total Holders: ${holders.length}\\n\\n`;\n\n  holders.forEach((holderAddress, index) => {\n    formattedText += `${index + 1}. ${holderAddress}\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `\\nSync Status: ${syncStatus.status} (lag: ${syncStatus.lag})\\n`;\n    formattedText += `Last Update: ${new Date(\n      syncStatus.timestamp * 1000\n    ).toLocaleString()}`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getNFTHoldersHandler = async (\n  provider: AnkrProvider,\n  request: GetNFTHoldersRequest\n): Promise<GetNFTHoldersReply> => {\n  return provider.getNFTHolders({\n    blockchain: request.blockchain as Blockchain,\n    contractAddress: request.contractAddress,\n    pageSize: 10,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetNFTHolders: Action = {\n  name: \"GET_NFT_HOLDERS_ANKR\",\n  similes: [\n    \"FETCH_NFT_HOLDERS\",\n    \"SHOW_NFT_HOLDERS\",\n    \"VIEW_NFT_HOLDERS\",\n    \"LIST_NFT_HOLDERS\",\n  ],\n  description:\n    \"Retrieve holders of specific NFTs on specified blockchain networks.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me holders of NFT contract 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258 on bsc\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetNFTHolders\",\n    requestValidator: validateGetNFTHoldersRequest,\n    requestSchema: getNFTHoldersRequestSchema,\n    methodHandler: getNFTHoldersHandler,\n    responseFormatter: formatGetNFTHoldersReply,\n  }),\n};\n\nexport default actionGetNFTHolders;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetNftTransfersReply,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getNFTTransfersRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get NFT transfers from\"),\n  contractAddress: z\n    .string()\n    .refine((val) => !val || val.startsWith(\"0x\"), {\n      message: \"Contract address must be empty or start with 0x\",\n    })\n    .optional()\n    .describe(\"The NFT contract address (optional)\"),\n  fromAddress: z\n    .string()\n    .refine((val) => !val || val.startsWith(\"0x\"), {\n      message: \"From address must be empty or start with 0x\",\n    })\n    .optional()\n    .describe(\"The sender address (optional)\"),\n  toAddress: z\n    .string()\n    .refine((val) => !val || val.startsWith(\"0x\"), {\n      message: \"To address must be empty or start with 0x\",\n    })\n    .optional()\n    .describe(\"The recipient address (optional)\"),\n  fromTimestamp: z\n    .number()\n    .optional()\n    .describe(\"Start timestamp for the transfers (optional)\"),\n  toTimestamp: z\n    .number()\n    .optional()\n    .describe(\"End timestamp for the transfers (optional)\"),\n});\n\ntype GetNFTTransfersRequest = z.infer<typeof getNFTTransfersRequestSchema>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetNFTTransfersRequest = (\n  content: unknown\n): content is GetNFTTransfersRequest => {\n  const result = getNFTTransfersRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n\n  // At least one of contractAddress, fromAddress, or toAddress must be provided\n  const typedContent = content as GetNFTTransfersRequest;\n  if (\n    !typedContent.contractAddress &&\n    !typedContent.fromAddress &&\n    !typedContent.toAddress\n  ) {\n    throw new ValidationError(\n      \"At least one of contractAddress, fromAddress, or toAddress must be provided\"\n    );\n  }\n\n  return true;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetNFTTransfersReply = (\n  request: GetNFTTransfersRequest,\n  response: GetNftTransfersReply\n): string => {\n  const { transfers, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `NFT Transfers on ${request.blockchain}:\\n\\n`;\n\n  if (request.contractAddress) {\n    formattedText += `Contract: ${request.contractAddress}\\n\\n`;\n  }\n\n  if (request.fromAddress) {\n    formattedText += `From Address: ${request.fromAddress}\\n\\n`;\n  }\n\n  if (request.toAddress) {\n    formattedText += `To Address: ${request.toAddress}\\n\\n`;\n  }\n\n  if (transfers.length === 0) {\n    formattedText += \"No NFT transfers found\";\n    return formattedText;\n  }\n\n  transfers.forEach((transfer, index) => {\n    const date = new Date(transfer.timestamp * 1000).toLocaleString();\n\n    formattedText += `${index + 1}. ${transfer.collectionName || \"NFT\"} (ID: ${\n      transfer.tokenId || \"Unknown\"\n    })\\n`;\n    formattedText += `   From: ${transfer.fromAddress.slice(\n      0,\n      6\n    )}...${transfer.fromAddress.slice(-4)}\\n`;\n    formattedText += `   To: ${transfer.toAddress.slice(\n      0,\n      6\n    )}...${transfer.toAddress.slice(-4)}\\n`;\n    formattedText += `   Contract: ${transfer.contractAddress.slice(\n      0,\n      6\n    )}...${transfer.contractAddress.slice(-4)}\\n`;\n    formattedText += `   Type: ${transfer.type}\\n`;\n    formattedText += `   Tx Hash: ${transfer.transactionHash.slice(\n      0,\n      6\n    )}...${transfer.transactionHash.slice(-4)}\\n`;\n    formattedText += `   Time: ${date}\\n\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `Sync Status: ${syncStatus.status} (lag: ${syncStatus.lag})\\n`;\n    formattedText += `Last Update: ${new Date(\n      syncStatus.timestamp * 1000\n    ).toLocaleString()}`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getNFTTransfersHandler = async (\n  provider: AnkrProvider,\n  request: GetNFTTransfersRequest\n): Promise<GetNftTransfersReply> => {\n  const params: any = {\n    blockchain: request.blockchain as Blockchain,\n    pageSize: 10,\n  };\n\n  if (request.contractAddress) {\n    params.contractAddress = request.contractAddress;\n  }\n\n  if (request.fromAddress) {\n    params.fromAddress = request.fromAddress;\n  }\n\n  if (request.toAddress) {\n    params.toAddress = request.toAddress;\n  }\n\n  if (request.fromTimestamp) {\n    params.fromTimestamp = request.fromTimestamp;\n  }\n\n  if (request.toTimestamp) {\n    params.toTimestamp = request.toTimestamp;\n  }\n\n  return provider.getNftTransfers(params);\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetNFTTransfers: Action = {\n  name: \"GET_NFT_TRANSFERS_ANKR\",\n  similes: [\n    \"FETCH_NFT_TRANSFERS\",\n    \"SHOW_NFT_TRANSFERS\",\n    \"VIEW_NFT_TRANSFERS\",\n    \"LIST_NFT_TRANSFERS\",\n  ],\n  description:\n    \"Retrieve NFT transfer history on specified blockchain networks.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me NFT transfers for contract 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d on eth\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetNFTTransfers\",\n    requestValidator: validateGetNFTTransfersRequest,\n    requestSchema: getNFTTransfersRequestSchema,\n    methodHandler: getNFTTransfersHandler,\n    responseFormatter: formatGetNFTTransfersReply,\n  }),\n};\n\nexport default actionGetNFTTransfers;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport { Action, IAgentRuntime, Memory, ActionExample } from \"@elizaos/core\";\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetNFTMetadataReply,\n} from \"@ankr.com/ankr.js\";\nimport { z } from \"zod\";\nimport { ValidationError } from \"../error/base\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getNFTMetadataRequestSchema = z.object({\n  blockchain: z\n    .nativeEnum(Blockchains)\n    .describe(\"The blockchain to get NFT metadata from\"),\n  contractAddress: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The NFT contract address\"),\n  tokenId: z.string().describe(\"The token ID of the NFT\"),\n});\n\ntype GetNFTMetadataRequest = z.infer<typeof getNFTMetadataRequestSchema>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetNFTMetadataRequest = (\n  content: unknown\n): content is GetNFTMetadataRequest => {\n  const result = getNFTMetadataRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetNFTMetadataReply = (\n  request: GetNFTMetadataRequest,\n  response: GetNFTMetadataReply\n): string => {\n  const { metadata, attributes, syncStatus } = response;\n\n  if (!metadata || !attributes) {\n    return `No metadata found for NFT with token ID ${request.tokenId} at contract ${request.contractAddress} on ${request.blockchain}`;\n  }\n\n  // Format the response text\n  let formattedText = `NFT Metadata for ${\n    attributes.name || `Token #${request.tokenId}`\n  }:\\n\\n`;\n\n  // Collection name (try to extract from NFT name if available)\n  const collectionName = attributes.name\n    ? attributes.name.split(\"#\")[0].trim()\n    : metadata.collectionName || \"Unknown Collection\";\n\n  formattedText += `Collection: ${collectionName}\\n`;\n  formattedText += `Contract: ${metadata.contractAddress.slice(\n    0,\n    6\n  )}...${metadata.contractAddress.slice(-4)} (${metadata.contractType})\\n\\n`;\n\n  if (attributes.description) {\n    formattedText += `Description: ${attributes.description}\\n\\n`;\n  }\n\n  if (attributes.traits && attributes.traits.length > 0) {\n    formattedText += \"Traits:\\n\";\n    for (const trait of attributes.traits) {\n      formattedText += `- ${trait.trait_type}: ${trait.value}\\n`;\n    }\n  }\n\n  if (attributes.imageUrl) {\n    formattedText += `\\nImage URL: ${attributes.imageUrl}\\n`;\n  }\n\n  if (attributes.tokenUrl) {\n    formattedText += `Token URL: ${attributes.tokenUrl}\\n`;\n  }\n\n  if (syncStatus) {\n    formattedText += `\\nSync Status: ${syncStatus.status} (lag: ${syncStatus.lag})\\n`;\n    formattedText += `Last Update: ${new Date(\n      syncStatus.timestamp * 1000\n    ).toLocaleString()}`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getNFTMetadataHandler = async (\n  provider: AnkrProvider,\n  request: GetNFTMetadataRequest\n): Promise<GetNFTMetadataReply> => {\n  return provider.getNFTMetadata({\n    blockchain: request.blockchain as Blockchain,\n    contractAddress: request.contractAddress,\n    tokenId: request.tokenId,\n    forceFetch: true,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetNFTMetadata: Action = {\n  name: \"GET_NFT_METADATA_ANKR\",\n  similes: [\"GET_NFT_INFO\", \"SHOW_NFT_DETAILS\", \"VIEW_NFT\", \"NFT_METADATA\"],\n  description:\n    \"Get detailed metadata for a specific NFT including traits, images, and contract information.\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me the metadata for NFT token 1234 at contract 0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d on eth\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetNFTMetadata\",\n    requestValidator: validateGetNFTMetadataRequest,\n    requestSchema: getNFTMetadataRequestSchema,\n    methodHandler: getNFTMetadataHandler,\n    responseFormatter: formatGetNFTMetadataReply,\n  }),\n};\n\nexport default actionGetNFTMetadata;\n","// ------------------------------------------------------------------------------------------------\n// Essential Imports\n// ------------------------------------------------------------------------------------------------\nimport {\n  AnkrProvider,\n  Blockchain,\n  GetNFTsByOwnerReply,\n} from \"@ankr.com/ankr.js\";\nimport { Action, ActionExample, IAgentRuntime, Memory } from \"@elizaos/core\";\nimport { z } from \"zod\";\nimport { Blockchains } from \"../ankr/blockchains\";\nimport { createAnkrHandler } from \"../ankr/handlerFactory\";\nimport { ValidationError } from \"../error/base\";\n\n// ------------------------------------------------------------------------------------------------\n// Types and Schemas\n// ------------------------------------------------------------------------------------------------\nexport const getNFTsByOwnerRequestSchema = z.object({\n  blockchain: z\n    .union([z.nativeEnum(Blockchains), z.array(z.nativeEnum(Blockchains))])\n    .optional()\n    .describe(\"The blockchain(s) to get NFTs from\"),\n  walletAddress: z\n    .string()\n    .startsWith(\"0x\")\n    .describe(\"The wallet address to get NFTs for\"),\n});\n\ntype GetNFTsByOwnerRequestType = z.infer<typeof getNFTsByOwnerRequestSchema>;\n\n// ------------------------------------------------------------------------------------------------\n// Validation Functions\n// ------------------------------------------------------------------------------------------------\nconst validateGetNFTsByOwnerRequest = (\n  content: unknown\n): content is GetNFTsByOwnerRequestType => {\n  const result = getNFTsByOwnerRequestSchema.safeParse(content);\n  if (!result.success) {\n    throw new ValidationError(result.error.message);\n  }\n  return result.success;\n};\n\n// ------------------------------------------------------------------------------------------------\n// Response Formatter\n// ------------------------------------------------------------------------------------------------\nconst formatGetNFTsByOwnerReply = (\n  request: GetNFTsByOwnerRequestType,\n  response: GetNFTsByOwnerReply\n): string => {\n  const { assets, syncStatus } = response;\n\n  // Format the response text\n  let formattedText = `NFTs owned by ${request.walletAddress}:\\n\\n`;\n\n  if (assets.length === 0) {\n    formattedText += \"No NFTs found\";\n    return formattedText;\n  }\n\n  assets.forEach((nft, index) => {\n    formattedText += `${index + 1}. ${nft.name || \"Unnamed NFT\"}\\n`;\n    formattedText += `   Collection: ${\n      nft.collectionName || \"Unknown Collection\"\n    }\\n`;\n    formattedText += `   Token ID: ${nft.tokenId}\\n`;\n    formattedText += `   Blockchain: ${nft.blockchain}\\n`;\n    formattedText += `   Contract: ${nft.contractAddress.slice(\n      0,\n      6\n    )}...${nft.contractAddress.slice(-4)}\\n`;\n\n    if (nft.quantity && nft.quantity !== \"1\") {\n      formattedText += `   Quantity: ${nft.quantity}\\n`;\n    }\n\n    formattedText += `   Type: ${nft.contractType}\\n\\n`;\n  });\n\n  if (syncStatus) {\n    formattedText += `Sync Status: ${syncStatus.status} (lag: ${syncStatus.lag})`;\n  }\n\n  return formattedText;\n};\n\n// ------------------------------------------------------------------------------------------------\n// API Method Handler\n// ------------------------------------------------------------------------------------------------\nconst getNFTsByOwnerHandler = async (\n  provider: AnkrProvider,\n  request: GetNFTsByOwnerRequestType\n): Promise<GetNFTsByOwnerReply> => {\n  return provider.getNFTsByOwner({\n    blockchain: request.blockchain as Blockchain | Blockchain[],\n    walletAddress: request.walletAddress,\n    pageSize: 10,\n  });\n};\n\n// ------------------------------------------------------------------------------------------------\n// Core Action implementation\n// ------------------------------------------------------------------------------------------------\nexport const actionGetNFTsByOwner: Action = {\n  name: \"GET_NFTS_BY_OWNER_ANKR\",\n  similes: [\n    \"LIST_NFTS\",\n    \"SHOW_NFTS\",\n    \"VIEW_NFTS\",\n    \"FETCH_NFTS\",\n    \"GET_OWNED_NFTS\",\n  ],\n  description:\n    \"Get NFTs owned by a specific wallet address across multiple blockchains\",\n  examples: [\n    [\n      {\n        user: \"user\",\n        content: {\n          text: \"Show me the NFTs owned by 0xd8da6bf26964af9d7eed9e03e53415d37aa96045\",\n        },\n      } as ActionExample,\n    ],\n  ],\n  validate: async (\n    _runtime: IAgentRuntime,\n    message: Memory\n  ): Promise<boolean> => {\n    return true;\n  },\n  handler: createAnkrHandler({\n    methodName: \"GetNFTsByOwner\",\n    requestValidator: validateGetNFTsByOwnerRequest,\n    requestSchema: getNFTsByOwnerRequestSchema,\n    methodHandler: getNFTsByOwnerHandler,\n    responseFormatter: formatGetNFTsByOwnerReply,\n  }),\n};\n\nexport default actionGetNFTsByOwner;\n"],"mappings":"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","names":["z","Blockchains","_a","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","z","blockchains","z","z","z","z","z","z","z","z"]}